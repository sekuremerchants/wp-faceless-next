{"version":3,"file":"/js/dist/theme-scripts/additional-polyfills.js","mappings":";;;;;;;;;;;;;;;;AAAA;AAC0B;AACK;;;;;;;;;;;;ACF/B;AACA;AACA;AACA;AACA;AACA,IAAIA,OAAA,CAAOC,MAAM,CAACC,WAAW,cAAYC,KAAK,iCAAAH,OAAA,CAALG,KAAK,IAAE;EAC5C,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAaC,KAAK,EAAEC,MAAM,EAAE;IACzCA,MAAM,GAAGA,MAAM,IAAI;MACfC,OAAO,EAAE,KAAK;MACdC,UAAU,EAAE,KAAK;MACjBC,MAAM,EAAEC;IACZ,CAAC;IACD,IAAMC,GAAG,GAAGC,QAAQ,CAACC,WAAW,CAAC,aAAa,CAAC;IAC/CF,GAAG,CAACG,eAAe,CAACT,KAAK,EAAEC,MAAM,CAACC,OAAO,EAAED,MAAM,CAACE,UAAU,EAAEF,MAAM,CAACG,MAAM,CAAC;IAC5E,OAAOE,GAAG;EACd,CAAC;EAEDP,WAAW,CAACW,SAAS,GAAGd,MAAM,CAACe,KAAK,CAACD,SAAS;EAE9Cd,MAAM,CAACC,WAAW,GAAGE,WAAW;AACpC;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,CAACH,MAAM,CAACgB,gBAAgB,EAAE;EAC1BhB,MAAM,CAACgB,gBAAgB,GAAI,UAAUP,SAAS,EAAE;IAC5C,YAAY;;IACZ;AACR;AACA;AACA;IACQ,SAASO,gBAAgBA,CAACC,QAAQ,EAAE;MAChC;AACZ;AACA;AACA;MACY,IAAI,CAACC,QAAQ,GAAG,EAAE;MAClB;MACA,IAAI,CAACC,SAAS,GAAGF,QAAQ;IAC7B;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASG,oBAAoBA,CAACC,QAAQ,EAAE;MACpC;MAAC,CAAC,SAASC,KAAKA,CAAA,EAAG;QACf,IAAIC,SAAS,GAAGF,QAAQ,CAACG,WAAW,CAAC,CAAC;QAEtC,IAAID,SAAS,CAACE,MAAM,EAAE;UAClB;UACA;UACAJ,QAAQ,CAACF,SAAS,CAACI,SAAS,EAAEF,QAAQ,CAAC;QAC3C;QACA;QACAA,QAAQ,CAACK,QAAQ,GAAGC,UAAU,CAACL,KAAK,EAAEN,gBAAgB,CAACY,OAAO,CAAC;MACnE,CAAC,EAAE,CAAC;IACR;;IAEA;AACR;AACA;AACA;AACA;IACQZ,gBAAgB,CAACY,OAAO,GAAG,EAAE,EAAC;;IAE9B;AACR;AACA;AACA;AACA;IACQZ,gBAAgB,CAACF,SAAS,GAAG;MACzB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;MACYe,OAAO,EAAE,SAATA,OAAOA,CAAYC,OAAO,EAAEC,MAAM,EAAE;QAChC;AAChB;AACA;AACA;QACgB,IAAIC,QAAQ,GAAG;UACXC,IAAI,EAAE,CAAC,EAAEF,MAAM,CAACG,UAAU,IAAIH,MAAM,CAACI,eAAe,IAAIJ,MAAM,CAACK,iBAAiB,CAAC;UAEjF;UACA;UACAC,IAAI,EAAE,CAAC,CAACN,MAAM,CAACO,SAAS;UACxBC,WAAW,EAAE,CAAC,CAACR,MAAM,CAACS,OAAO;UAC7BC,QAAQ,EAAE,CAAC,EAAEV,MAAM,CAACW,aAAa,IAAIX,MAAM,CAACY,qBAAqB;QACrE,CAAC;QAED,IAAIC,OAAO,GAAG,IAAI,CAAC1B,QAAQ;;QAE3B;QACA,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,OAAO,CAACnB,MAAM,EAAEoB,CAAC,EAAE,EAAE;UACrC,IAAID,OAAO,CAACC,CAAC,CAAC,CAACC,GAAG,KAAKhB,OAAO,EAAEc,OAAO,CAACG,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC;QACxD;QAEA,IAAId,MAAM,CAACI,eAAe,EAAE;UACxB;AACpB;AACA;AACA;UACoBH,QAAQ,CAACgB,OAAO,GAAGC,MAAM,CACrBlB,MAAM,CAACI,eAAe,EACtB,UAAUe,CAAC,EAAEC,CAAC,EAAE;YACZD,CAAC,CAACC,CAAC,CAAC,GAAG,IAAI;YACX,OAAOD,CAAC;UACZ,CAAC,EACD,CAAC,CACL,CAAC;QACL;QAEAN,OAAO,CAACQ,IAAI,CAAC;UACTN,GAAG,EAAEhB,OAAO;UACZuB,EAAE,EAAEC,sBAAsB,CAACxB,OAAO,EAAEE,QAAQ;QAChD,CAAC,CAAC;;QAEF;QACA,IAAI,CAAC,IAAI,CAACN,QAAQ,EAAE;UAChBN,oBAAoB,CAAC,IAAI,CAAC;QAC9B;MACJ,CAAC;MAED;AACZ;AACA;AACA;AACA;MACYI,WAAW,EAAE,SAAbA,WAAWA,CAAA,EAAc;QACrB,IAAID,SAAS,GAAG,EAAE;QAClB,IAAIqB,OAAO,GAAG,IAAI,CAAC1B,QAAQ;QAE3B,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,OAAO,CAACnB,MAAM,EAAEoB,CAAC,EAAE,EAAE;UACrCD,OAAO,CAACC,CAAC,CAAC,CAACQ,EAAE,CAAC9B,SAAS,CAAC;QAC5B;QAEA,OAAOA,SAAS;MACpB,CAAC;MAED;AACZ;AACA;AACA;MACYgC,UAAU,EAAE,SAAZA,UAAUA,CAAA,EAAc;QACpB,IAAI,CAACrC,QAAQ,GAAG,EAAE,EAAC;QACnBsC,YAAY,CAAC,IAAI,CAAC9B,QAAQ,CAAC,EAAC;QAC5B;QACA,IAAI,CAACA,QAAQ,GAAG,IAAI;MACxB;IACJ,CAAC;;IAED;AACR;AACA;AACA;AACA;IACQ,SAAS+B,cAAcA,CAACC,IAAI,EAAE;MAC1B,IAAI1B,QAAQ,GAAG;QACX;QACA2B,IAAI,EAAE,IAAI;QACVC,MAAM,EAAE,IAAI;QACZC,UAAU,EAAE,EAAE;QACdC,YAAY,EAAE,EAAE;QAChBC,eAAe,EAAE,IAAI;QACrBC,WAAW,EAAE,IAAI;QACjBC,aAAa,EAAE,IAAI;QACnBC,kBAAkB,EAAE,IAAI;QACxBC,QAAQ,EAAE;MACd,CAAC;MACD,KAAK,IAAIC,IAAI,IAAIV,IAAI,EAAE;QACnB,IAAIW,GAAG,CAACrC,QAAQ,EAAEoC,IAAI,CAAC,IAAIV,IAAI,CAACU,IAAI,CAAC,KAAK3D,SAAS,EAAEuB,QAAQ,CAACoC,IAAI,CAAC,GAAGV,IAAI,CAACU,IAAI,CAAC;MACpF;MACA,OAAOpC,QAAQ;IACnB;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASsB,sBAAsBA,CAACxB,OAAO,EAAEC,MAAM,EAAE;MAC7C;MACA,IAAIuC,SAAS,GAAGC,KAAK,CAACzC,OAAO,EAAEC,MAAM,CAAC,EAAC;;MAEvC;AACZ;AACA;AACA;AACA;MACY,OAAO,UAAUR,SAAS,EAAE;QACxB,IAAIiD,IAAI,GAAGjD,SAAS,CAACE,MAAM;UACvBgD,KAAK;QAET,IAAI1C,MAAM,CAACU,QAAQ,IAAIX,OAAO,CAAC4C,QAAQ,KAAK,CAAC,IAAI5C,OAAO,CAAC6C,SAAS,KAAKL,SAAS,CAAC7B,QAAQ,EAAE;UACvFlB,SAAS,CAAC6B,IAAI,CACV,IAAIK,cAAc,CAAC;YACfE,IAAI,EAAE,eAAe;YACrBC,MAAM,EAAE9B,OAAO;YACfqC,QAAQ,EAAEG,SAAS,CAAC7B;UACxB,CAAC,CACL,CAAC;QACL;;QAEA;QACA,IAAIV,MAAM,CAACE,IAAI,IAAIqC,SAAS,CAACrC,IAAI,EAAE;UAC/B2C,sBAAsB,CAACrD,SAAS,EAAEO,OAAO,EAAEwC,SAAS,CAACrC,IAAI,EAAEF,MAAM,CAACiB,OAAO,CAAC;QAC9E;;QAEA;QACA,IAAIjB,MAAM,CAACM,IAAI,IAAIN,MAAM,CAACQ,WAAW,EAAE;UACnCkC,KAAK,GAAGI,aAAa,CAACtD,SAAS,EAAEO,OAAO,EAAEwC,SAAS,EAAEvC,MAAM,CAAC;QAChE;;QAEA;QACA,IAAI0C,KAAK,IAAIlD,SAAS,CAACE,MAAM,KAAK+C,IAAI,EAAE;UACpC;UACAF,SAAS,GAAGC,KAAK,CAACzC,OAAO,EAAEC,MAAM,CAAC;QACtC;MACJ,CAAC;IACL;;IAEA;;IAEA;IACA;IACA,IAAI+C,eAAe,GAAGnE,QAAQ,CAACoE,aAAa,CAAC,GAAG,CAAC;IACjDD,eAAe,CAACE,KAAK,CAACC,GAAG,GAAG,CAAC;IAC7BH,eAAe,GAAGA,eAAe,CAAC5C,UAAU,CAAC8C,KAAK,CAACE,KAAK,IAAI,MAAM;;IAElE;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,kBAAkBA,CAACC,EAAE,EAAEnD,IAAI,EAAE;MAClC;MACA;MACA;MACA,OAAOA,IAAI,CAACiD,KAAK;IACrB;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASG,yBAAyBA,CAACD,EAAE,EAAEnD,IAAI,EAAE;MACzC;MACA,OAAOA,IAAI,CAACqD,IAAI,KAAK,OAAO,GAAGrD,IAAI,CAACiD,KAAK,GAAGE,EAAE,CAACJ,KAAK,CAACO,OAAO;IAChE;IAEA,IAAIC,iBAAiB,GAAGV,eAAe,GAAGK,kBAAkB,GAAGE,yBAAyB;;IAExF;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAAST,sBAAsBA,CAACrD,SAAS,EAAEO,OAAO,EAAEwC,SAAS,EAAEmB,MAAM,EAAE;MACnE,IAAIC,OAAO,GAAG,CAAC,CAAC;MAChB,IAAIxD,UAAU,GAAGJ,OAAO,CAACI,UAAU;MACnC,IAAID,IAAI;MACR,IAAIqD,IAAI;MACR,IAAIzC,CAAC,GAAGX,UAAU,CAACT,MAAM;MACzB,OAAOoB,CAAC,EAAE,EAAE;QACRZ,IAAI,GAAGC,UAAU,CAACW,CAAC,CAAC;QACpByC,IAAI,GAAGrD,IAAI,CAACqD,IAAI;QAChB,IAAI,CAACG,MAAM,IAAIpB,GAAG,CAACoB,MAAM,EAAEH,IAAI,CAAC,EAAE;UAC9B,IAAIE,iBAAiB,CAAC1D,OAAO,EAAEG,IAAI,CAAC,KAAKqC,SAAS,CAACgB,IAAI,CAAC,EAAE;YACtD;YACA/D,SAAS,CAAC6B,IAAI,CACVK,cAAc,CAAC;cACXE,IAAI,EAAE,YAAY;cAClBC,MAAM,EAAE9B,OAAO;cACfmC,aAAa,EAAEqB,IAAI;cACnBnB,QAAQ,EAAEG,SAAS,CAACgB,IAAI,CAAC;cACzBpB,kBAAkB,EAAEjC,IAAI,CAAC0D,YAAY,CAAC;YAC1C,CAAC,CACL,CAAC;UACL;UACAD,OAAO,CAACJ,IAAI,CAAC,GAAG,IAAI;QACxB;MACJ;MACA,KAAKA,IAAI,IAAIhB,SAAS,EAAE;QACpB,IAAI,CAACoB,OAAO,CAACJ,IAAI,CAAC,EAAE;UAChB/D,SAAS,CAAC6B,IAAI,CACVK,cAAc,CAAC;YACXG,MAAM,EAAE9B,OAAO;YACf6B,IAAI,EAAE,YAAY;YAClBM,aAAa,EAAEqB,IAAI;YACnBnB,QAAQ,EAAEG,SAAS,CAACgB,IAAI;UAC5B,CAAC,CACL,CAAC;QACL;MACJ;IACJ;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAAST,aAAaA,CAACtD,SAAS,EAAEO,OAAO,EAAEwC,SAAS,EAAEvC,MAAM,EAAE;MAC1D;MACA,IAAI0C,KAAK;MACT;AACZ;AACA;AACA;AACA;AACA;MACY,SAASmB,gBAAgBA,CAACC,SAAS,EAAEC,IAAI,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,aAAa,EAAE;QACvE;QACA,IAAIC,QAAQ,GAAGL,SAAS,CAACpE,MAAM,GAAG,CAAC;QACnC;QACA;QACA,IAAI0E,OAAO,GAAG,CAAC,EAAE,CAACD,QAAQ,GAAGD,aAAa,IAAI,CAAC,CAAC;QAChD,IAAIG,IAAI;QACR,IAAIC,SAAS;QACb,IAAIC,QAAQ;QACZ,OAAQA,QAAQ,GAAGT,SAAS,CAACU,GAAG,CAAC,CAAC,EAAG;UACjCH,IAAI,GAAGL,KAAK,CAACO,QAAQ,CAACzD,CAAC,CAAC;UACxBwD,SAAS,GAAGL,QAAQ,CAACM,QAAQ,CAACE,CAAC,CAAC;;UAEhC;UACA;UACA,IAAIzE,MAAM,CAACM,IAAI,IAAI8D,OAAO,IAAIM,IAAI,CAACC,GAAG,CAACJ,QAAQ,CAACzD,CAAC,GAAGyD,QAAQ,CAACE,CAAC,CAAC,IAAIN,QAAQ,EAAE;YACzE3E,SAAS,CAAC6B,IAAI,CACVK,cAAc,CAAC;cACXE,IAAI,EAAE,WAAW;cACjBC,MAAM,EAAEkC,IAAI;cACZjC,UAAU,EAAE,CAACuC,IAAI,CAAC;cAClBtC,YAAY,EAAE,CAACsC,IAAI,CAAC;cACpB;cACApC,WAAW,EAAEoC,IAAI,CAACpC,WAAW;cAC7BD,eAAe,EAAEqC,IAAI,CAACrC;YAC1B,CAAC,CACL,CAAC;YACDoC,OAAO,EAAE,EAAC;UACd;;UAEA;UACA,IAAIpE,MAAM,CAACE,IAAI,IAAIoE,SAAS,CAACpE,IAAI,EAC7B2C,sBAAsB,CAACrD,SAAS,EAAE6E,IAAI,EAAEC,SAAS,CAACpE,IAAI,EAAEF,MAAM,CAACiB,OAAO,CAAC;UAC3E,IAAIjB,MAAM,CAACU,QAAQ,IAAI2D,IAAI,CAAC1B,QAAQ,KAAK,CAAC,IAAI0B,IAAI,CAACzB,SAAS,KAAK0B,SAAS,CAAC5D,QAAQ,EAAE;YACjFlB,SAAS,CAAC6B,IAAI,CACVK,cAAc,CAAC;cACXE,IAAI,EAAE,eAAe;cACrBC,MAAM,EAAEwC,IAAI;cACZjC,QAAQ,EAAEkC,SAAS,CAAC5D;YACxB,CAAC,CACL,CAAC;UACL;UACA;UACA,IAAIV,MAAM,CAACQ,WAAW,EAAEoE,aAAa,CAACP,IAAI,EAAEC,SAAS,CAAC;QAC1D;MACJ;;MAEA;AACZ;AACA;AACA;AACA;MACY,SAASM,aAAaA,CAACb,IAAI,EAAEc,GAAG,EAAE;QAC9B,IAAIb,KAAK,GAAGD,IAAI,CAACe,UAAU;QAC3B,IAAIb,QAAQ,GAAGY,GAAG,CAACvE,IAAI;QACvB,IAAIyE,IAAI,GAAGf,KAAK,CAACtE,MAAM;QACvB;QACA,IAAI+C,IAAI,GAAGwB,QAAQ,GAAGA,QAAQ,CAACvE,MAAM,GAAG,CAAC;QACzC;;QAEA;QACA;QACA,IAAIsF,GAAG;QACP;QACA,IAAIlB,SAAS;QACb,IAAImB,EAAE,EAAC;QACP,IAAIC,GAAG,EAAC;;QAER,IAAIZ,SAAS;QACb;QACA,IAAID,IAAI;QACR,IAAIc,IAAI;QACR;QACA,IAAIjB,aAAa,GAAG,CAAC;;QAErB;QACA,IAAIpD,CAAC,GAAG,CAAC;UACL2D,CAAC,GAAG,CAAC;QACT;QACA,OAAO3D,CAAC,GAAGiE,IAAI,IAAIN,CAAC,GAAGhC,IAAI,EAAE;UACzB;UACA4B,IAAI,GAAGL,KAAK,CAAClD,CAAC,CAAC;UACfwD,SAAS,GAAGL,QAAQ,CAACQ,CAAC,CAAC;UACvBU,IAAI,GAAGb,SAAS,IAAIA,SAAS,CAACP,IAAI;UAElC,IAAIM,IAAI,KAAKc,IAAI,EAAE;YACf;YACA;YACA,IAAInF,MAAM,CAACE,IAAI,IAAIoE,SAAS,CAACpE,IAAI,EAC7B,8CAA+C2C,sBAAsB,CACjErD,SAAS,EACT6E,IAAI,EACJC,SAAS,CAACpE,IAAI,EACdF,MAAM,CAACiB,OACX,CAAC;YACL;YACA,IACIjB,MAAM,CAACU,QAAQ,IACf4D,SAAS,CAAC5D,QAAQ,KAAKhC,SAAS,IAChC2F,IAAI,CAACzB,SAAS,KAAK0B,SAAS,CAAC5D,QAAQ,EACvC;cACElB,SAAS,CAAC6B,IAAI,CACVK,cAAc,CAAC;gBACXE,IAAI,EAAE,eAAe;gBACrBC,MAAM,EAAEwC,IAAI;gBACZjC,QAAQ,EAAEkC,SAAS,CAAC5D;cACxB,CAAC,CACL,CAAC;YACL;;YAEA;YACA,IAAIoD,SAAS,EAAED,gBAAgB,CAACC,SAAS,EAAEC,IAAI,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,aAAa,CAAC;;YAEhF;YACA,IAAIlE,MAAM,CAACQ,WAAW,KAAK6D,IAAI,CAACS,UAAU,CAACpF,MAAM,IAAK4E,SAAS,CAAChE,IAAI,IAAIgE,SAAS,CAAChE,IAAI,CAACZ,MAAO,CAAC,EAC3FkF,aAAa,CAACP,IAAI,EAAEC,SAAS,CAAC;YAElCxD,CAAC,EAAE;YACH2D,CAAC,EAAE;UACP,CAAC,MAAM;YACH;YACA/B,KAAK,GAAG,IAAI;YACZ,IAAI,CAACsC,GAAG,EAAE;cACN;cACAA,GAAG,GAAG,CAAC,CAAC;cACRlB,SAAS,GAAG,EAAE;YAClB;YACA,IAAIO,IAAI,EAAE;cACN;cACA,IAAI,CAACW,GAAG,CAAEC,EAAE,GAAGG,YAAY,CAACf,IAAI,CAAC,CAAE,EAAE;gBACjC;gBACA;gBACAW,GAAG,CAACC,EAAE,CAAC,GAAG,IAAI;gBACd;gBACA,IAAI,CAACC,GAAG,GAAGG,iBAAiB,CAACpB,QAAQ,EAAEI,IAAI,EAAEI,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE;kBACrD,IAAIzE,MAAM,CAACM,IAAI,EAAE;oBACbd,SAAS,CAAC6B,IAAI,CACVK,cAAc,CAAC;sBACXE,IAAI,EAAE,WAAW;sBACjBC,MAAM,EAAEkC,IAAI;sBACZjC,UAAU,EAAE,CAACuC,IAAI,CAAC;sBAAE;sBACpBpC,WAAW,EAAEoC,IAAI,CAACpC,WAAW;sBAC7BD,eAAe,EAAEqC,IAAI,CAACrC;oBAC1B,CAAC,CACL,CAAC;oBACDkC,aAAa,EAAE;kBACnB;gBACJ,CAAC,MAAM;kBACHJ,SAAS,CAACzC,IAAI,CAAC;oBACX;oBACAP,CAAC,EAAEA,CAAC;oBACJ2D,CAAC,EAAES;kBACP,CAAC,CAAC;gBACN;cACJ;cACApE,CAAC,EAAE;YACP;YAEA,IACIqE,IAAI;YACJ;YACAA,IAAI,KAAKnB,KAAK,CAAClD,CAAC,CAAC,EACnB;cACE,IAAI,CAACkE,GAAG,CAAEC,EAAE,GAAGG,YAAY,CAACD,IAAI,CAAC,CAAE,EAAE;gBACjCH,GAAG,CAACC,EAAE,CAAC,GAAG,IAAI;gBACd,IAAI,CAACC,GAAG,GAAGI,OAAO,CAACtB,KAAK,EAAEmB,IAAI,EAAErE,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE;kBACxC,IAAId,MAAM,CAACM,IAAI,EAAE;oBACbd,SAAS,CAAC6B,IAAI,CACVK,cAAc,CAAC;sBACXE,IAAI,EAAE,WAAW;sBACjBC,MAAM,EAAEgD,GAAG,CAACd,IAAI;sBAChBhC,YAAY,EAAE,CAACoD,IAAI,CAAC;sBACpBlD,WAAW,EAAEgC,QAAQ,CAACQ,CAAC,GAAG,CAAC,CAAC;sBAAE;sBAC9BzC,eAAe,EAAEiC,QAAQ,CAACQ,CAAC,GAAG,CAAC;oBACnC,CAAC,CACL,CAAC;oBACDP,aAAa,EAAE;kBACnB;gBACJ,CAAC,MAAM;kBACHJ,SAAS,CAACzC,IAAI,CAAC;oBACXP,CAAC,EAAEoE,GAAG;oBACNT,CAAC,EAAEA;kBACP,CAAC,CAAC;gBACN;cACJ;cACAA,CAAC,EAAE;YACP;UACJ,CAAC,CAAC;QACN,CAAC,CAAC;;QAEF;QACA,IAAIX,SAAS,EAAED,gBAAgB,CAACC,SAAS,EAAEC,IAAI,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,aAAa,CAAC;MACpF;MACAU,aAAa,CAAC7E,OAAO,EAAEwC,SAAS,CAAC;MACjC,OAAOG,KAAK;IAChB;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASF,KAAKA,CAACzC,OAAO,EAAEC,MAAM,EAAE;MAC5B,IAAIuF,OAAO,GAAG,IAAI,EAAC;MACnB,OAAQ,SAASC,IAAIA,CAACzF,OAAO,EAAE;QAC3B,IAAI0F,SAAS,GAAG;UACZ;UACA1B,IAAI,EAAEhE;QACV,CAAC;;QAED;QACA;QACA,IAAIC,MAAM,CAACU,QAAQ,KAAKX,OAAO,CAAC4C,QAAQ,KAAK,CAAC,IAAI5C,OAAO,CAAC4C,QAAQ,KAAK,CAAC,CAAC,EAAE;UACvE8C,SAAS,CAAC/E,QAAQ,GAAGX,OAAO,CAAC6C,SAAS;QAC1C;QACA;QAAA,KACK;UACD;UACA;UACA,IAAI5C,MAAM,CAACE,IAAI,IAAIqF,OAAO,IAAIxF,OAAO,CAAC4C,QAAQ,KAAK,CAAC,EAAE;YAClD;AACxB;AACA;AACA;YACwB8C,SAAS,CAACvF,IAAI,GAAGgB,MAAM,CACnBnB,OAAO,CAACI,UAAU,EAClB,UAAUuF,IAAI,EAAExF,IAAI,EAAE;cAClB,IAAI,CAACF,MAAM,CAACiB,OAAO,IAAIjB,MAAM,CAACiB,OAAO,CAACf,IAAI,CAACqD,IAAI,CAAC,EAAE;gBAC9CmC,IAAI,CAACxF,IAAI,CAACqD,IAAI,CAAC,GAAGE,iBAAiB,CAAC1D,OAAO,EAAEG,IAAI,CAAC;cACtD;cACA,OAAOwF,IAAI;YACf,CAAC,EACD,CAAC,CACL,CAAC;UACL;;UAEA;UACA,IAAIH,OAAO,KAAKvF,MAAM,CAACM,IAAI,IAAIN,MAAM,CAACU,QAAQ,IAAKV,MAAM,CAACE,IAAI,IAAIF,MAAM,CAACQ,WAAY,CAAC,EAAE;YACpF;YACAiF,SAAS,CAACnF,IAAI,GAAG0E,GAAG,CAACjF,OAAO,CAAC+E,UAAU,EAAEU,IAAI,CAAC;UAClD;UAEAD,OAAO,GAAGvF,MAAM,CAACQ,WAAW;QAChC;QACA,OAAOiF,SAAS;MACpB,CAAC,CAAE1F,OAAO,CAAC;IACf;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASsF,iBAAiBA,CAACM,GAAG,EAAEC,KAAK,EAAEV,GAAG,EAAE;MACxC,OAAOI,OAAO,CAACK,GAAG,EAAEC,KAAK,EAAEV,GAAG,EAAEW,yBAAyB,CAAC,MAAM,CAAC,CAAC;IACtE;;IAEA;IACA,IAAIzB,OAAO,GAAG,CAAC,EAAC;IAChB;IACA,IAAI0B,OAAO,GAAG,OAAO;;IAErB;AACR;AACA;AACA;AACA;AACA;IACQ,SAASV,YAAYA,CAACW,IAAI,EAAE;MACxB,IAAI;QACA,OAAOA,IAAI,CAACd,EAAE,KAAKc,IAAI,CAACD,OAAO,CAAC,GAAGC,IAAI,CAACD,OAAO,CAAC,IAAI1B,OAAO,EAAE,CAAC;MAClE,CAAC,CAAC,OAAO4B,GAAG,EAAE;QACV;QACA,IAAI;UACA,OAAOD,IAAI,CAACnD,SAAS,EAAC;QAC1B,CAAC,CAAC,OAAOqD,MAAM,EAAE;UACb;UACA,OAAO7B,OAAO,EAAE;QACpB;MACJ;IACJ;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAASY,GAAGA,CAACW,GAAG,EAAEO,QAAQ,EAAE;MACxB,IAAIC,OAAO,GAAG,EAAE;MAChB,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGT,GAAG,CAACjG,MAAM,EAAE0G,KAAK,EAAE,EAAE;QAC7CD,OAAO,CAACC,KAAK,CAAC,GAAGF,QAAQ,CAACP,GAAG,CAACS,KAAK,CAAC,EAAEA,KAAK,EAAET,GAAG,CAAC;MACrD;MACA,OAAOQ,OAAO;IAClB;;IAEA;AACR;AACA;AACA;AACA;AACA;IACQ,SAASjF,MAAMA,CAACyE,GAAG,EAAEO,QAAQ,EAAER,IAAI,EAAE;MACjC,KAAK,IAAIU,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGT,GAAG,CAACjG,MAAM,EAAE0G,KAAK,EAAE,EAAE;QAC7CV,IAAI,GAAGQ,QAAQ,CAACR,IAAI,EAAEC,GAAG,CAACS,KAAK,CAAC,EAAEA,KAAK,EAAET,GAAG,CAAC;MACjD;MACA,OAAOD,IAAI;IACf;;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,SAASJ,OAAOA,CAACK,GAAG,EAAEU,IAAI,EAAEnB,GAAG,EAAE7C,IAAI,EAAE;MACnC,OAAO,eAAgB6C,GAAG,GAAGS,GAAG,CAACjG,MAAM,EAAEwF,GAAG,EAAE,EAAE;QAC5C;QACA,IAAI,CAAC7C,IAAI,GAAGsD,GAAG,CAACT,GAAG,CAAC,CAAC7C,IAAI,CAAC,GAAGsD,GAAG,CAACT,GAAG,CAAC,MAAMmB,IAAI,EAAE,OAAOnB,GAAG;MAC/D;MACA,OAAO,CAAC,CAAC;IACb;;IAEA;AACR;AACA;AACA;AACA;IACQ,SAAS5C,GAAGA,CAACgE,GAAG,EAAEjE,IAAI,EAAE;MACpB,OAAOiE,GAAG,CAACjE,IAAI,CAAC,KAAK3D,SAAS,EAAC;IACnC;;IAEA;IACA,SAASmH,yBAAyBA,CAAC1E,CAAC,EAAE;MAClC,OAAOA,CAAC;IACZ;IAEA,OAAOlC,gBAAgB;EAC3B,CAAC,CAAE,KAAK,CAAC,CAAC;AACd;;;;;;;;;;AC9pBA,IAAI,CAACsH,MAAM,CAACC,MAAM,EAAE;EAChBD,MAAM,CAACE,cAAc,CAACF,MAAM,EAAE,QAAQ,EAAE;IACpCG,UAAU,EAAE,KAAK;IACjBC,YAAY,EAAE,IAAI;IAClBC,QAAQ,EAAE,IAAI;IACdzD,KAAK,EAAE,SAAPA,KAAKA,CAAYtB,MAAM,EAAE;MACrB,YAAY;;MACZ,IAAIA,MAAM,KAAKnD,SAAS,IAAImD,MAAM,KAAK,IAAI,EAAE;QACzC,MAAM,IAAIgF,SAAS,CAAC,yCAAyC,CAAC;MAClE;MAEA,IAAIC,EAAE,GAAGP,MAAM,CAAC1E,MAAM,CAAC;MACvB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiG,SAAS,CAACrH,MAAM,EAAEoB,CAAC,EAAE,EAAE;QACvC,IAAIkG,UAAU,GAAGD,SAAS,CAACjG,CAAC,CAAC;QAC7B,IAAIkG,UAAU,KAAKtI,SAAS,IAAIsI,UAAU,KAAK,IAAI,EAAE;UACjD;QACJ;QACAA,UAAU,GAAGT,MAAM,CAACS,UAAU,CAAC;QAE/B,IAAIC,SAAS,GAAGV,MAAM,CAACW,IAAI,CAACX,MAAM,CAACS,UAAU,CAAC,CAAC;QAC/C,KAAK,IAAIG,SAAS,GAAG,CAAC,EAAEC,GAAG,GAAGH,SAAS,CAACvH,MAAM,EAAEyH,SAAS,GAAGC,GAAG,EAAED,SAAS,EAAE,EAAE;UAC1E,IAAIE,OAAO,GAAGJ,SAAS,CAACE,SAAS,CAAC;UAClC,IAAIG,IAAI,GAAGf,MAAM,CAACgB,wBAAwB,CAACP,UAAU,EAAEK,OAAO,CAAC;UAC/D,IAAIC,IAAI,KAAK5I,SAAS,IAAI4I,IAAI,CAACZ,UAAU,EAAE;YACvCI,EAAE,CAACO,OAAO,CAAC,GAAGL,UAAU,CAACK,OAAO,CAAC;UACrC;QACJ;MACJ;MACA,OAAOP,EAAE;IACb;EACJ,CAAC,CAAC;AACN;;AAEA;AACA;AACA","sources":["webpack://sekure-website/./assets/js/src/theme/polyfills/additional-polyfills-init.js","webpack://sekure-website/./assets/js/src/theme/polyfills/custom-event.js","webpack://sekure-website/./assets/js/src/theme/polyfills/mutation-observer.js","webpack://sekure-website/./assets/js/src/theme/polyfills/object-assign.js"],"sourcesContent":["// custom polyfills for window.MutationObserver + CustomEvent + Object.assign polyfills\r\nimport './custom-event.js'\r\nimport './mutation-observer.js'\r\nimport './object-assign.js'\r\n","/**\r\n * Modern browsers already support new CustomEvent\r\n * Remember to switch to CustomEvent in your application\r\n */\r\n// If IE\r\nif (typeof window.CustomEvent !== typeof isNaN) {\r\n    const customEvent = function (event, params) {\r\n        params = params || {\r\n            bubbles: false,\r\n            cancelable: false,\r\n            detail: undefined\r\n        }\r\n        const evt = document.createEvent('CustomEvent')\r\n        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail)\r\n        return evt\r\n    }\r\n\r\n    customEvent.prototype = window.Event.prototype\r\n\r\n    window.CustomEvent = customEvent\r\n}\r\n","/*!\r\n * Shim for MutationObserver interface\r\n * Author: Graeme Yeates (github.com/megawac)\r\n * Repository: https://github.com/megawac/MutationObserver.js\r\n * License: WTFPL V2, 2004 (wtfpl.net).\r\n * Though credit and staring the repo will make me feel pretty, you can modify and redistribute as you please.\r\n * Attempts to follow spec (https://www.w3.org/TR/dom/#mutation-observers) as closely as possible for native javascript\r\n * See https://github.com/WebKit/webkit/blob/master/Source/WebCore/dom/MutationObserver.cpp for current webkit source c++ implementation\r\n */\r\n\r\n/**\r\n * prefix bugs:\r\n    - https://bugs.webkit.org/show_bug.cgi?id=85161\r\n    - https://bugzilla.mozilla.org/show_bug.cgi?id=749920\r\n * Don't use WebKitMutationObserver as Safari (6.0.5-6.1) use a buggy implementation\r\n*/\r\nif (!window.MutationObserver) {\r\n    window.MutationObserver = (function (undefined) {\r\n        'use strict'\r\n        /**\r\n         * @param {function(Array.<MutationRecord>, MutationObserver)} listener\r\n         * @constructor\r\n         */\r\n        function MutationObserver(listener) {\r\n            /**\r\n             * @type {Array.<Object>}\r\n             * @private\r\n             */\r\n            this._watched = []\r\n            /** @private */\r\n            this._listener = listener\r\n        }\r\n\r\n        /**\r\n         * Start a recursive timeout function to check all items being observed for mutations\r\n         * @type {MutationObserver} observer\r\n         * @private\r\n         */\r\n        function startMutationChecker(observer) {\r\n            ;(function check() {\r\n                var mutations = observer.takeRecords()\r\n\r\n                if (mutations.length) {\r\n                    // fire away\r\n                    // calling the listener with context is not spec but currently consistent with FF and WebKit\r\n                    observer._listener(mutations, observer)\r\n                }\r\n                /** @private */\r\n                observer._timeout = setTimeout(check, MutationObserver._period)\r\n            })()\r\n        }\r\n\r\n        /**\r\n         * Period to check for mutations (~32 times/sec)\r\n         * @type {number}\r\n         * @expose\r\n         */\r\n        MutationObserver._period = 30 /*ms+runtime*/\r\n\r\n        /**\r\n         * Exposed API\r\n         * @expose\r\n         * @final\r\n         */\r\n        MutationObserver.prototype = {\r\n            /**\r\n             * see https://dom.spec.whatwg.org/#dom-mutationobserver-observe\r\n             * not going to throw here but going to follow the current spec config sets\r\n             * @param {Node|null} $target\r\n             * @param {Object|null} config : MutationObserverInit configuration dictionary\r\n             * @expose\r\n             * @return undefined\r\n             */\r\n            observe: function ($target, config) {\r\n                /**\r\n                 * Using slightly different names so closure can go ham\r\n                 * @type {!Object} : A custom mutation config\r\n                 */\r\n                var settings = {\r\n                    attr: !!(config.attributes || config.attributeFilter || config.attributeOldValue),\r\n\r\n                    // some browsers enforce that subtree must be set with childList, attributes or characterData.\r\n                    // We don't care as spec doesn't specify this rule.\r\n                    kids: !!config.childList,\r\n                    descendents: !!config.subtree,\r\n                    charData: !!(config.characterData || config.characterDataOldValue)\r\n                }\r\n\r\n                var watched = this._watched\r\n\r\n                // remove already observed target element from pool\r\n                for (var i = 0; i < watched.length; i++) {\r\n                    if (watched[i].tar === $target) watched.splice(i, 1)\r\n                }\r\n\r\n                if (config.attributeFilter) {\r\n                    /**\r\n                     * converts to a {key: true} dict for faster lookup\r\n                     * @type {Object.<String,Boolean>}\r\n                     */\r\n                    settings.afilter = reduce(\r\n                        config.attributeFilter,\r\n                        function (a, b) {\r\n                            a[b] = true\r\n                            return a\r\n                        },\r\n                        {}\r\n                    )\r\n                }\r\n\r\n                watched.push({\r\n                    tar: $target,\r\n                    fn: createMutationSearcher($target, settings)\r\n                })\r\n\r\n                // reconnect if not connected\r\n                if (!this._timeout) {\r\n                    startMutationChecker(this)\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Finds mutations since last check and empties the \"record queue\" i.e. mutations will only be found once\r\n             * @expose\r\n             * @return {Array.<MutationRecord>}\r\n             */\r\n            takeRecords: function () {\r\n                var mutations = []\r\n                var watched = this._watched\r\n\r\n                for (var i = 0; i < watched.length; i++) {\r\n                    watched[i].fn(mutations)\r\n                }\r\n\r\n                return mutations\r\n            },\r\n\r\n            /**\r\n             * @expose\r\n             * @return undefined\r\n             */\r\n            disconnect: function () {\r\n                this._watched = [] // clear the stuff being observed\r\n                clearTimeout(this._timeout) // ready for garbage collection\r\n                /** @private */\r\n                this._timeout = null\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Simple MutationRecord pseudoclass. No longer exposing as its not fully compliant\r\n         * @param {Object} data\r\n         * @return {Object} a MutationRecord\r\n         */\r\n        function MutationRecord(data) {\r\n            var settings = {\r\n                // technically these should be on proto so hasOwnProperty will return false for non explicitly props\r\n                type: null,\r\n                target: null,\r\n                addedNodes: [],\r\n                removedNodes: [],\r\n                previousSibling: null,\r\n                nextSibling: null,\r\n                attributeName: null,\r\n                attributeNamespace: null,\r\n                oldValue: null\r\n            }\r\n            for (var prop in data) {\r\n                if (has(settings, prop) && data[prop] !== undefined) settings[prop] = data[prop]\r\n            }\r\n            return settings\r\n        }\r\n\r\n        /**\r\n         * Creates a func to find all the mutations\r\n         *\r\n         * @param {Node} $target\r\n         * @param {!Object} config : A custom mutation config\r\n         */\r\n        function createMutationSearcher($target, config) {\r\n            /** type {Elestuct} */\r\n            var $oldstate = clone($target, config) // create the cloned datastructure\r\n\r\n            /**\r\n             * consumes array of mutations we can push to\r\n             *\r\n             * @param {Array.<MutationRecord>} mutations\r\n             */\r\n            return function (mutations) {\r\n                var olen = mutations.length,\r\n                    dirty\r\n\r\n                if (config.charData && $target.nodeType === 3 && $target.nodeValue !== $oldstate.charData) {\r\n                    mutations.push(\r\n                        new MutationRecord({\r\n                            type: 'characterData',\r\n                            target: $target,\r\n                            oldValue: $oldstate.charData\r\n                        })\r\n                    )\r\n                }\r\n\r\n                // Alright we check base level changes in attributes... easy\r\n                if (config.attr && $oldstate.attr) {\r\n                    findAttributeMutations(mutations, $target, $oldstate.attr, config.afilter)\r\n                }\r\n\r\n                // check childlist or subtree for mutations\r\n                if (config.kids || config.descendents) {\r\n                    dirty = searchSubtree(mutations, $target, $oldstate, config)\r\n                }\r\n\r\n                // reclone data structure if theres changes\r\n                if (dirty || mutations.length !== olen) {\r\n                    /** type {Elestuct} */\r\n                    $oldstate = clone($target, config)\r\n                }\r\n            }\r\n        }\r\n\r\n        /* attributes + attributeFilter helpers */\r\n\r\n        // Check if the environment has the attribute bug (#4) which cause\r\n        // element.attributes.style to always be null.\r\n        var hasAttributeBug = document.createElement('i')\r\n        hasAttributeBug.style.top = 0\r\n        hasAttributeBug = hasAttributeBug.attributes.style.value != 'null'\r\n\r\n        /**\r\n         * Gets an attribute value in an environment without attribute bug\r\n         *\r\n         * @param {Node} el\r\n         * @param {Attr} attr\r\n         * @return {String} an attribute value\r\n         */\r\n        function getAttributeSimple(el, attr) {\r\n            // There is a potential for a warning to occur here if the attribute is a\r\n            // custom attribute in IE<9 with a custom .toString() method. This is\r\n            // just a warning and doesn't affect execution (see #21)\r\n            return attr.value\r\n        }\r\n\r\n        /**\r\n         * Gets an attribute value with special hack for style attribute (see #4)\r\n         *\r\n         * @param {Node} el\r\n         * @param {Attr} attr\r\n         * @return {String} an attribute value\r\n         */\r\n        function getAttributeWithStyleHack(el, attr) {\r\n            // As with getAttributeSimple there is a potential warning for custom attribtues in IE7.\r\n            return attr.name !== 'style' ? attr.value : el.style.cssText\r\n        }\r\n\r\n        var getAttributeValue = hasAttributeBug ? getAttributeSimple : getAttributeWithStyleHack\r\n\r\n        /**\r\n         * fast helper to check to see if attributes object of an element has changed\r\n         * doesnt handle the textnode case\r\n         *\r\n         * @param {Array.<MutationRecord>} mutations\r\n         * @param {Node} $target\r\n         * @param {Object.<string, string>} $oldstate : Custom attribute clone data structure from clone\r\n         * @param {Object} filter\r\n         */\r\n        function findAttributeMutations(mutations, $target, $oldstate, filter) {\r\n            var checked = {}\r\n            var attributes = $target.attributes\r\n            var attr\r\n            var name\r\n            var i = attributes.length\r\n            while (i--) {\r\n                attr = attributes[i]\r\n                name = attr.name\r\n                if (!filter || has(filter, name)) {\r\n                    if (getAttributeValue($target, attr) !== $oldstate[name]) {\r\n                        // The pushing is redundant but gzips very nicely\r\n                        mutations.push(\r\n                            MutationRecord({\r\n                                type: 'attributes',\r\n                                target: $target,\r\n                                attributeName: name,\r\n                                oldValue: $oldstate[name],\r\n                                attributeNamespace: attr.namespaceURI // in ie<8 it incorrectly will return undefined\r\n                            })\r\n                        )\r\n                    }\r\n                    checked[name] = true\r\n                }\r\n            }\r\n            for (name in $oldstate) {\r\n                if (!checked[name]) {\r\n                    mutations.push(\r\n                        MutationRecord({\r\n                            target: $target,\r\n                            type: 'attributes',\r\n                            attributeName: name,\r\n                            oldValue: $oldstate[name]\r\n                        })\r\n                    )\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * searchSubtree: array of mutations so far, element, element clone, bool\r\n         * synchronous dfs comparision of two nodes\r\n         * This function is applied to any observed element with childList or subtree specified\r\n         * Sorry this is kind of confusing as shit, tried to comment it a bit...\r\n         * codereview.stackexchange.com/questions/38351 discussion of an earlier version of this func\r\n         *\r\n         * @param {Array} mutations\r\n         * @param {Node} $target\r\n         * @param {!Object} $oldstate : A custom cloned node from clone()\r\n         * @param {!Object} config : A custom mutation config\r\n         */\r\n        function searchSubtree(mutations, $target, $oldstate, config) {\r\n            // Track if the tree is dirty and has to be recomputed (#14).\r\n            var dirty\r\n            /*\r\n             * Helper to identify node rearrangment and stuff...\r\n             * There is no gaurentee that the same node will be identified for both added and removed nodes\r\n             * if the positions have been shuffled.\r\n             * conflicts array will be emptied by end of operation\r\n             */\r\n            function resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes) {\r\n                // the distance between the first conflicting node and the last\r\n                var distance = conflicts.length - 1\r\n                // prevents same conflict being resolved twice consider when two nodes switch places.\r\n                // only one should be given a mutation event (note -~ is used as a math.ceil shorthand)\r\n                var counter = -~((distance - numAddedNodes) / 2)\r\n                var $cur\r\n                var oldstruct\r\n                var conflict\r\n                while ((conflict = conflicts.pop())) {\r\n                    $cur = $kids[conflict.i]\r\n                    oldstruct = $oldkids[conflict.j]\r\n\r\n                    // attempt to determine if there was node rearrangement... won't gaurentee all matches\r\n                    // also handles case where added/removed nodes cause nodes to be identified as conflicts\r\n                    if (config.kids && counter && Math.abs(conflict.i - conflict.j) >= distance) {\r\n                        mutations.push(\r\n                            MutationRecord({\r\n                                type: 'childList',\r\n                                target: node,\r\n                                addedNodes: [$cur],\r\n                                removedNodes: [$cur],\r\n                                // haha don't rely on this please\r\n                                nextSibling: $cur.nextSibling,\r\n                                previousSibling: $cur.previousSibling\r\n                            })\r\n                        )\r\n                        counter-- // found conflict\r\n                    }\r\n\r\n                    // Alright we found the resorted nodes now check for other types of mutations\r\n                    if (config.attr && oldstruct.attr)\r\n                        findAttributeMutations(mutations, $cur, oldstruct.attr, config.afilter)\r\n                    if (config.charData && $cur.nodeType === 3 && $cur.nodeValue !== oldstruct.charData) {\r\n                        mutations.push(\r\n                            MutationRecord({\r\n                                type: 'characterData',\r\n                                target: $cur,\r\n                                oldValue: oldstruct.charData\r\n                            })\r\n                        )\r\n                    }\r\n                    // now look @ subtree\r\n                    if (config.descendents) findMutations($cur, oldstruct)\r\n                }\r\n            }\r\n\r\n            /**\r\n             * Main worker. Finds and adds mutations if there are any\r\n             * @param {Node} node\r\n             * @param {!Object} old : A cloned data structure using internal clone\r\n             */\r\n            function findMutations(node, old) {\r\n                var $kids = node.childNodes\r\n                var $oldkids = old.kids\r\n                var klen = $kids.length\r\n                // $oldkids will be undefined for text and comment nodes\r\n                var olen = $oldkids ? $oldkids.length : 0\r\n                // if (!olen && !klen) return; // both empty; clearly no changes\r\n\r\n                // we delay the intialization of these for marginal performance in the expected case (actually quite signficant on large subtrees when these would be otherwise unused)\r\n                // map of checked element of ids to prevent registering the same conflict twice\r\n                var map\r\n                // array of potential conflicts (ie nodes that may have been re arranged)\r\n                var conflicts\r\n                var id // element id from getElementId helper\r\n                var idx // index of a moved or inserted element\r\n\r\n                var oldstruct\r\n                // current and old nodes\r\n                var $cur\r\n                var $old\r\n                // track the number of added nodes so we can resolve conflicts more accurately\r\n                var numAddedNodes = 0\r\n\r\n                // iterate over both old and current child nodes at the same time\r\n                var i = 0,\r\n                    j = 0\r\n                // while there is still anything left in $kids or $oldkids (same as i < $kids.length || j < $oldkids.length;)\r\n                while (i < klen || j < olen) {\r\n                    // current and old nodes at the indexs\r\n                    $cur = $kids[i]\r\n                    oldstruct = $oldkids[j]\r\n                    $old = oldstruct && oldstruct.node\r\n\r\n                    if ($cur === $old) {\r\n                        // expected case - optimized for this case\r\n                        // check attributes as specified by config\r\n                        if (config.attr && oldstruct.attr)\r\n                            /* oldstruct.attr instead of textnode check */ findAttributeMutations(\r\n                                mutations,\r\n                                $cur,\r\n                                oldstruct.attr,\r\n                                config.afilter\r\n                            )\r\n                        // check character data if node is a comment or textNode and it's being observed\r\n                        if (\r\n                            config.charData &&\r\n                            oldstruct.charData !== undefined &&\r\n                            $cur.nodeValue !== oldstruct.charData\r\n                        ) {\r\n                            mutations.push(\r\n                                MutationRecord({\r\n                                    type: 'characterData',\r\n                                    target: $cur,\r\n                                    oldValue: oldstruct.charData\r\n                                })\r\n                            )\r\n                        }\r\n\r\n                        // resolve conflicts; it will be undefined if there are no conflicts - otherwise an array\r\n                        if (conflicts) resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes)\r\n\r\n                        // recurse on next level of children. Avoids the recursive call when there are no children left to iterate\r\n                        if (config.descendents && ($cur.childNodes.length || (oldstruct.kids && oldstruct.kids.length)))\r\n                            findMutations($cur, oldstruct)\r\n\r\n                        i++\r\n                        j++\r\n                    } else {\r\n                        // (uncommon case) lookahead until they are the same again or the end of children\r\n                        dirty = true\r\n                        if (!map) {\r\n                            // delayed initalization (big perf benefit)\r\n                            map = {}\r\n                            conflicts = []\r\n                        }\r\n                        if ($cur) {\r\n                            // check id is in the location map otherwise do a indexOf search\r\n                            if (!map[(id = getElementId($cur))]) {\r\n                                // to prevent double checking\r\n                                // mark id as found\r\n                                map[id] = true\r\n                                // custom indexOf using comparitor checking oldkids[i].node === $cur\r\n                                if ((idx = indexOfCustomNode($oldkids, $cur, j)) === -1) {\r\n                                    if (config.kids) {\r\n                                        mutations.push(\r\n                                            MutationRecord({\r\n                                                type: 'childList',\r\n                                                target: node,\r\n                                                addedNodes: [$cur], // $cur is a new node\r\n                                                nextSibling: $cur.nextSibling,\r\n                                                previousSibling: $cur.previousSibling\r\n                                            })\r\n                                        )\r\n                                        numAddedNodes++\r\n                                    }\r\n                                } else {\r\n                                    conflicts.push({\r\n                                        // add conflict\r\n                                        i: i,\r\n                                        j: idx\r\n                                    })\r\n                                }\r\n                            }\r\n                            i++\r\n                        }\r\n\r\n                        if (\r\n                            $old &&\r\n                            // special case: the changes may have been resolved: i and j appear congurent so we can continue using the expected case\r\n                            $old !== $kids[i]\r\n                        ) {\r\n                            if (!map[(id = getElementId($old))]) {\r\n                                map[id] = true\r\n                                if ((idx = indexOf($kids, $old, i)) === -1) {\r\n                                    if (config.kids) {\r\n                                        mutations.push(\r\n                                            MutationRecord({\r\n                                                type: 'childList',\r\n                                                target: old.node,\r\n                                                removedNodes: [$old],\r\n                                                nextSibling: $oldkids[j + 1], // praise no indexoutofbounds exception\r\n                                                previousSibling: $oldkids[j - 1]\r\n                                            })\r\n                                        )\r\n                                        numAddedNodes--\r\n                                    }\r\n                                } else {\r\n                                    conflicts.push({\r\n                                        i: idx,\r\n                                        j: j\r\n                                    })\r\n                                }\r\n                            }\r\n                            j++\r\n                        }\r\n                    } // end uncommon case\r\n                } // end loop\r\n\r\n                // resolve any remaining conflicts\r\n                if (conflicts) resolveConflicts(conflicts, node, $kids, $oldkids, numAddedNodes)\r\n            }\r\n            findMutations($target, $oldstate)\r\n            return dirty\r\n        }\r\n\r\n        /**\r\n         * Utility\r\n         * Cones a element into a custom data structure designed for comparision. https://gist.github.com/megawac/8201012\r\n         *\r\n         * @param {Node} $target\r\n         * @param {!Object} config : A custom mutation config\r\n         * @return {!Object} : Cloned data structure\r\n         */\r\n        function clone($target, config) {\r\n            var recurse = true // set true so childList we'll always check the first level\r\n            return (function copy($target) {\r\n                var elestruct = {\r\n                    /** @type {Node} */\r\n                    node: $target\r\n                }\r\n\r\n                // Store current character data of target text or comment node if the config requests\r\n                // those properties to be observed.\r\n                if (config.charData && ($target.nodeType === 3 || $target.nodeType === 8)) {\r\n                    elestruct.charData = $target.nodeValue\r\n                }\r\n                // its either a element, comment, doc frag or document node\r\n                else {\r\n                    // Add attr only if subtree is specified or top level and avoid if\r\n                    // attributes is a document object (#13).\r\n                    if (config.attr && recurse && $target.nodeType === 1) {\r\n                        /**\r\n                         * clone live attribute list to an object structure {name: val}\r\n                         * @type {Object.<string, string>}\r\n                         */\r\n                        elestruct.attr = reduce(\r\n                            $target.attributes,\r\n                            function (memo, attr) {\r\n                                if (!config.afilter || config.afilter[attr.name]) {\r\n                                    memo[attr.name] = getAttributeValue($target, attr)\r\n                                }\r\n                                return memo\r\n                            },\r\n                            {}\r\n                        )\r\n                    }\r\n\r\n                    // whether we should iterate the children of $target node\r\n                    if (recurse && (config.kids || config.charData || (config.attr && config.descendents))) {\r\n                        /** @type {Array.<!Object>} : Array of custom clone */\r\n                        elestruct.kids = map($target.childNodes, copy)\r\n                    }\r\n\r\n                    recurse = config.descendents\r\n                }\r\n                return elestruct\r\n            })($target)\r\n        }\r\n\r\n        /**\r\n         * indexOf an element in a collection of custom nodes\r\n         *\r\n         * @param {NodeList} set\r\n         * @param {!Object} $node : A custom cloned node\r\n         * @param {number} idx : index to start the loop\r\n         * @return {number}\r\n         */\r\n        function indexOfCustomNode(set, $node, idx) {\r\n            return indexOf(set, $node, idx, JSCompiler_renameProperty('node'))\r\n        }\r\n\r\n        // using a non id (eg outerHTML or nodeValue) is extremely naive and will run into issues with nodes that may appear the same like <li></li>\r\n        var counter = 1 // don't use 0 as id (falsy)\r\n        /** @const */\r\n        var expando = 'mo_id'\r\n\r\n        /**\r\n         * Attempt to uniquely id an element for hashing. We could optimize this for legacy browsers but it hopefully wont be called enough to be a concern\r\n         *\r\n         * @param {Node} $ele\r\n         * @return {(string|number)}\r\n         */\r\n        function getElementId($ele) {\r\n            try {\r\n                return $ele.id || ($ele[expando] = $ele[expando] || counter++)\r\n            } catch (o_O) {\r\n                // ie <8 will throw if you set an unknown property on a text node\r\n                try {\r\n                    return $ele.nodeValue // naive\r\n                } catch (shitie) {\r\n                    // when text node is removed: https://gist.github.com/megawac/8355978 :(\r\n                    return counter++\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * **map** Apply a mapping function to each item of a set\r\n         * @param {Array|NodeList} set\r\n         * @param {Function} iterator\r\n         */\r\n        function map(set, iterator) {\r\n            var results = []\r\n            for (var index = 0; index < set.length; index++) {\r\n                results[index] = iterator(set[index], index, set)\r\n            }\r\n            return results\r\n        }\r\n\r\n        /**\r\n         * **Reduce** builds up a single result from a list of values\r\n         * @param {Array|NodeList|NamedNodeMap} set\r\n         * @param {Function} iterator\r\n         * @param {*} [memo] Initial value of the memo.\r\n         */\r\n        function reduce(set, iterator, memo) {\r\n            for (var index = 0; index < set.length; index++) {\r\n                memo = iterator(memo, set[index], index, set)\r\n            }\r\n            return memo\r\n        }\r\n\r\n        /**\r\n         * **indexOf** find index of item in collection.\r\n         * @param {Array|NodeList} set\r\n         * @param {Object} item\r\n         * @param {number} idx\r\n         * @param {string} [prop] Property on set item to compare to item\r\n         */\r\n        function indexOf(set, item, idx, prop) {\r\n            for (; /*idx = ~~idx*/ idx < set.length; idx++) {\r\n                // start idx is always given as this is internal\r\n                if ((prop ? set[idx][prop] : set[idx]) === item) return idx\r\n            }\r\n            return -1\r\n        }\r\n\r\n        /**\r\n         * @param {Object} obj\r\n         * @param {(string|number)} prop\r\n         * @return {boolean}\r\n         */\r\n        function has(obj, prop) {\r\n            return obj[prop] !== undefined // will be nicely inlined by gcc\r\n        }\r\n\r\n        // GCC hack see https://stackoverflow.com/a/23202438/1517919\r\n        function JSCompiler_renameProperty(a) {\r\n            return a\r\n        }\r\n\r\n        return MutationObserver\r\n    })(void 0)\r\n}\r\n","if (!Object.assign) {\r\n    Object.defineProperty(Object, 'assign', {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (target) {\r\n            'use strict'\r\n            if (target === undefined || target === null) {\r\n                throw new TypeError('Cannot convert first argument to object')\r\n            }\r\n\r\n            var to = Object(target)\r\n            for (var i = 1; i < arguments.length; i++) {\r\n                var nextSource = arguments[i]\r\n                if (nextSource === undefined || nextSource === null) {\r\n                    continue\r\n                }\r\n                nextSource = Object(nextSource)\r\n\r\n                var keysArray = Object.keys(Object(nextSource))\r\n                for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\r\n                    var nextKey = keysArray[nextIndex]\r\n                    var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey)\r\n                    if (desc !== undefined && desc.enumerable) {\r\n                        to[nextKey] = nextSource[nextKey]\r\n                    }\r\n                }\r\n            }\r\n            return to\r\n        }\r\n    })\r\n}\r\n\r\n// const obj = {a: 1}\r\n// const copy = Object.assign({}, obj)\r\n// console.log(copy) // { a: 1 }\r\n"],"names":["_typeof","window","CustomEvent","isNaN","customEvent","event","params","bubbles","cancelable","detail","undefined","evt","document","createEvent","initCustomEvent","prototype","Event","MutationObserver","listener","_watched","_listener","startMutationChecker","observer","check","mutations","takeRecords","length","_timeout","setTimeout","_period","observe","$target","config","settings","attr","attributes","attributeFilter","attributeOldValue","kids","childList","descendents","subtree","charData","characterData","characterDataOldValue","watched","i","tar","splice","afilter","reduce","a","b","push","fn","createMutationSearcher","disconnect","clearTimeout","MutationRecord","data","type","target","addedNodes","removedNodes","previousSibling","nextSibling","attributeName","attributeNamespace","oldValue","prop","has","$oldstate","clone","olen","dirty","nodeType","nodeValue","findAttributeMutations","searchSubtree","hasAttributeBug","createElement","style","top","value","getAttributeSimple","el","getAttributeWithStyleHack","name","cssText","getAttributeValue","filter","checked","namespaceURI","resolveConflicts","conflicts","node","$kids","$oldkids","numAddedNodes","distance","counter","$cur","oldstruct","conflict","pop","j","Math","abs","findMutations","old","childNodes","klen","map","id","idx","$old","getElementId","indexOfCustomNode","indexOf","recurse","copy","elestruct","memo","set","$node","JSCompiler_renameProperty","expando","$ele","o_O","shitie","iterator","results","index","item","obj","Object","assign","defineProperty","enumerable","configurable","writable","TypeError","to","arguments","nextSource","keysArray","keys","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor"],"sourceRoot":""}